'''
Created on May 19, 2014

@author: ajn
'''

import numpy
from filter import ParticleTrajectory

class Simulator():
    """ Class interfacing filters/smoothers to assisst in solving estimation problem"""
    def __init__(self, model, u, y):
        """ model - object of class describing problem type
            u - inputs (first dimension is the time index)
            y - measurements (first dimension is the time index) """
        if (u != None):
            self.u = u
        else:
            self.u = [None] * len(y)
        self.y = y
        self.pt = None
        self.straj = None
        self.params = None
        self.model = model

    def set_params(self, params):
        """ Set the parameters of the model (if any) """
        self.params = numpy.copy(params)
        self.model.set_params(self.params)

    def simulate(self, num_part, num_traj, filter='PF', smoother='full',
                 smoother_options=None, res=0.67, meas_first=False):
        """" Solve the estimation problem;
            num_part - Number of particles used in the forward filter
            num_traj - Number of backward trajectories generated by the smoother
            filter - The filter algorithm to use
            smooter - The smoothing algorithm to use
            smoother_options - algorithm specific smoother options
            res - resampling threshold for the forward filter
            meas_first - Is the first measurement of the initial state (true) or
                         after the first time update? (false) """
        resamplings = 0

        # Initialise a particle filter with our particle approximation of the initial state,
        # set the resampling threshold to 0.67 (effective particles / total particles )
        self.pt = ParticleTrajectory(self.model, num_part, res, filter=filter)

        offset = 0
        # Run particle filter
        if (meas_first):
            self.pt.measure(self.y[0])
            offset = 1
        for i in range(offset, len(self.y)):
            # Run PF using noise corrupted input signal
            if (self.pt.forward(self.u[i - offset], self.y[i])):
                resamplings = resamplings + 1

        # Use the filtered estimates above to created smoothed estimates
        if (smoother != None):
            self.straj = self.pt.perform_smoothing(num_traj, method=smoother,
                                                   smoother_options=smoother_options)
        return resamplings

    def get_filtered_estimates(self):
        """" Returns a (est, w)
            est is a (T, N, D) array containing all particles
            w is a (T,D) array containing all particle weights
            T is the length of the dataset, N is the number of particles and 
            D is the dimension of each particle"""

        T = len(self.pt.traj)
        N = self.pt.traj[0].pa.part.shape[0]
        D = self.pt.traj[0].pa.part.shape[1]

        est = numpy.empty((T, N, D))

        w = numpy.empty((T, N))

        for t in xrange(T):
            wtmp = numpy.exp(self.pt.traj[t].pa.w)
            w[t] = wtmp / numpy.sum(wtmp)
            est[t] = self.pt.traj[t].pa.part

        return (est, w)

    def get_filtered_mean(self):
        (est, w) = self.get_filtered_estimates()

        T = len(self.pt.traj)
        D = self.pt.traj[0].pa.part.shape[1]

        mean = numpy.empty((T, D))
        for t in xrange(T):
            mean[t] = numpy.sum((w[t].ravel() * est[t].T).T, 0)

        return mean
    def get_smoothed_estimates(self):
        """" Returns a (T, N, D) array where T is the length of the dataset,
            N is the number of particles and D is the dimension of each 
            particle"""
        return self.straj.traj

    def get_smoothed_mean(self):
        return numpy.mean(self.straj.traj, 1)