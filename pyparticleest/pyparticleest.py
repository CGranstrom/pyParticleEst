'''
Created on May 19, 2014

@author: ajn
'''

import numpy
from filter import ParticleTrajectory

class Simulator():
    """ Class interfacing filters/smoothers to assisst in solving estimation problem"""
    def __init__(self, model, u, y):
        """ model - object of class describing problem type
            u - inputs (first dimension is the time index)
            y - measurements (first dimension is the time index) """
        if (u != None):
            self.u = u
        else:
            self.u = [None] * len(y)
        self.y = y
        self.pt = None
        self.straj = None
        self.params = None
        self.model = model
    
    def set_params(self, params):
        """ Set the parameters of the model (if any) """
        self.params = numpy.copy(params)
        self.model.set_params(self.params)
    
    def simulate(self, num_part, num_traj, filter='PF', smoother='full', smoother_options=None, res=0.67, meas_first=False):
        """" Solve the estimation problem;
            num_part - Number of particles used in the forward filter
            num_traj - Number of backward trajectories generated by the smoother
            filter - The filter algorithm to use
            smooter - The smoothing algorithm to use
            smoother_options - algorithm specific smoother options
            res - resampling threshold for the forward filter
            meas_first - Is the first measurement of the initial state (true) or
                         after the first time update? (false) """
        resamplings=0
    
        # Initialise a particle filter with our particle approximation of the initial state,
        # set the resampling threshold to 0.67 (effective particles / total particles )
        self.pt = ParticleTrajectory(self.model, num_part, res,filter=filter)
        
        offset = 0
        # Run particle filter
        if (meas_first):
            self.pt.measure(self.y[0])
            offset = 1
        for i in range(offset,len(self.y)):
            # Run PF using noise corrupted input signal
            if (self.pt.forward(self.u[i-offset], self.y[i])):
                resamplings = resamplings + 1
            
        # Use the filtered estimates above to created smoothed estimates
        if (smoother != None):
            self.straj = self.pt.perform_smoothing(num_traj, method=smoother, smoother_options=smoother_options)
        return resamplings